# HIL Scheduler Configuration

general:
  log_level: INFO

time:
  timezone: "Europe/Madrid"

schedule:
  source_csv: "schedule_source.csv"
  duration_h: 0.5
  default_resolution_min: 5

startup:
  schedule_source: "manual"    # manual | api
  transport_mode: "local"      # local | remote

istentore_api:
  base_url: "https://3mku48kfxf.execute-api.eu-south-2.amazonaws.com/default"
  email: "i-STENTORE"
  poll_start_time: "17:30"
  schedule_period_minutes: 15
  post_measurements_in_api_mode: true
  measurement_post_period_s: 60
  measurement_post_queue_maxlen: 2000
  measurement_post_retry_initial_s: 2
  measurement_post_retry_max_s: 60

timing:
  data_fetcher_period_s: 120
  scheduler_period_s: 2
  plant_period_s: 2
  measurement_period_s: 2
  measurements_write_period_s: 60

recording:
  compression:
    enabled: true
    tolerances:
      p_setpoint_kw: 0.0
      battery_active_power_kw: 0.1
      q_setpoint_kvar: 0.0
      battery_reactive_power_kvar: 0.1
      soc_pu: 0.001
      p_poi_kw: 0.1
      q_poi_kvar: 0.1
      v_poi_pu: 0.001

plants:
  lib:
    name: "LIB"
    model:
      capacity_kwh: 500.0
      initial_soc_pu: 0.5
      power_limits:
        p_max_kw: 1000.0
        p_min_kw: -1000.0
        q_max_kvar: 600.0
        q_min_kvar: -600.0
      poi_voltage_v: 20000.0
    modbus:
      local:
        host: "localhost"
        port: 5020 # El puerto en el PLC es el 502, supongo que está cambiado adrede
        registers:
          p_setpoint_in: 86
          p_poi: 290
          p_battery: 270
          q_setpoint_in: 88
          q_poi: 292
          q_battery: 272
          v_poi: 296
          enable: 1
          soc: 281
          # He añadido en "remote" el registro "stop_command". No sé si lo tienes que duplicar también en "local" o no, pero lo pongo aquí para que lo tengas en cuenta.
      remote:
        host: "10.117.133.21"
        port: 502
        registers:
          p_setpoint_in: 86
          p_poi: 290
          p_battery: 270
          q_setpoint_in: 88
          q_poi: 292
          q_battery: 272
          v_poi: 296
          enable: 1 # El enable permite la escritura en la batería. Debe estar a 1 para permitir escritura
          soc: 281
          stop_command: 85 # 1: stop, 0: start. Este registro debe estar a 0 para permitir la operación normal de la batería. Si se pone a 1, la batería se detiene y no responde a comandos de potencia.
    measurement_series:
      soc: 4
      p: 6
      q: 7
      v: 8

  vrfb:
    name: "VRFB"
    model:
      capacity_kwh: 400
      initial_soc_pu: 0.5
      power_limits:
        p_max_kw: 160
        p_min_kw: -160
        q_max_kvar: 64
        q_min_kvar: -64
      poi_voltage_v: 220 # En vez de 20000 que sería la tensión en el POC, te pongo 220 V, que es la tensión ac del inversor, tal y como lo he implementado en el RTDS. Lo pongo así para que las medidas "poi" coincidan con las de la salida del inversor y no tengamos que usar la IP del analizador.
    modbus:
      local:
        host: "localhost" # He puesto los mismos registros que en "remote". No sé si prefieres que estén los mismos o no.
        port: 5021 # El puerto en el RTDS es el 502, supongo que está cambiado adrede
        registers:
          p_setpoint_in: 1
          p_poi: 14
          p_battery: 14
          q_setpoint_in: 2
          q_poi: 15
          q_battery: 15
          v_poi: 29
          enable: 7
          soc: 22
          stop_command: 0
      remote:
        host: "10.117.133.26"
        port: 502
        registers:
          p_setpoint_in: 1
          p_poi: 14 # Como te he comentado, realmente es la potencia a la salida del inversor (las medidas en el POC, tras impedancias y trafos estarían en el analizador, que tiene otra IP).
          p_battery: 14
          q_setpoint_in: 2
          q_poi: 15 # Lo mismo que el p_poi, realmente es la q a la salida del inversor.
          q_battery: 15
          v_poi: 29 # Lo mismo que el p_poi, realmente es la tensión a la salida del inversor.
          enable: 7 # Este registro debe estar a 1 para permitir el control de la vrfb desde el orquestador
          soc: 22
          start_command: 0 # 2: start, 0: stop. Este registro debe estar a 2 para permitir la operación normal de la batería. Si se pone a 0, la batería se detiene y no responde a comandos de potencia.
          # IMPORTANTE QUE DEBE ESTAR A 2, NO A 1. Lo he implementado así porque lo hice análogo al mapa de CEN. Es distinto que para la LIB porque en la LIB es el PLC el que manda el 2. Aquí, al no estar en medio el PLC, lo tiene que mandar directamente el orquestador. Si esto supone un incoveniente, lo cambio.
    measurement_series:
      soc: 5
      p: 11
      q: 10
      v: 9
